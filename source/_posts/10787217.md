---
title: 【门外汉深度学习-5】一个老问题
date: 2017-04-02 12:05:38
tags:
	- 机器学习
	- 深度学习
	- 神经网络
	- Youtube
categories: 机器学习
---
# 前言
本文源自YouTube网站《[Deep Learning SIMPLIFIED](https://www.youtube.com/watch?v=b99UVkWzYTQ&index=1&list=PLjJh1vlSEYgvGod9wWiydumYl8hOXixNu)》系列视频，文章内容为视频的字幕，供深度学习初学者参考学习。

# 主体内容

![](http://upload-images.jianshu.io/upload_images/291600-18f5baa567c324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

So now you're probably thinking - wow, deep nets are really great! But why did it take so long for them to become popular? Well as it turns out, when you try to train them with a method called **backpropagation**（反向传播）, you run into a fundamental problem called the **vanishing gradient**（消失梯度）, or sometimes the **exploding gradient**（爆发梯度）. When that happens, training takes too long and the accuracy really suffers. Let's take a closer look.

When you're training a neural net, you're constantly calculating a cost value. The cost is typically the difference between the net's predicted output and the actual output from a set of labelled training data. The cost is then lowered by making slight adjustments to the weights and biases over and over throughout the training process, until the lowest possible value is obtained. Here is that forward prop again; and here are the example weights and biases.

![](http://upload-images.jianshu.io/upload_images/291600-9f1aa39cff6f8bd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

The training process utilizes something called a **gradient**（梯度）, which measures the rate at which the cost will change with respect to a change in a weight or a bias.

![](http://upload-images.jianshu.io/upload_images/291600-32682b72029d39d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

**Deep architectures** are your best and sometimes your only choice for complex machine learning problems such as facial recognition. But up until 2006, there was no way to accurately train deep nets due to a fundamental problem with the training process: the **vanishing gradient**.

![](http://upload-images.jianshu.io/upload_images/291600-51768f97898e6cec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

Let's think of a gradient like a slope, and the training process like a rock rolling down that slope. A rock will roll quickly down a steep slope but will barely move at all on a flat surface. The same is true with the gradient of a deep net. When the gradient is large, the net will train quickly. When the gradient is small, the net will train slowly.

![](http://upload-images.jianshu.io/upload_images/291600-10dc44a68b2f3eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

Here's that deep net again.

![](http://upload-images.jianshu.io/upload_images/291600-f662f490a0d10129.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

And here is how the gradient could potentially vanish or decay back through the net. As you can see, the gradients are much small in the earlier layers. As a result, the early layers of the network are the slowest to train. But this is a fundamental problem! The early layers are responsible for detecting the simple patterns and the building blocks -when it came to facial recognition, the early layers detected the edges which were combined to form facial features later in the network. 

![](http://upload-images.jianshu.io/upload_images/291600-4eb36da118574ae0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

And if the early layers get it wrong, the result built up by the net will be wrong as well. It could mean that instead of a face like this, your net looks for this.

![](http://upload-images.jianshu.io/upload_images/291600-6779922e5ad7b679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

The process used for training a neural net is called **back-propagation** or **back-prop**（反向传播）. We saw before that **forward prop** starts with the inputs and works forward; **back-prop** does the reverse, calculating the gradient from right to left.

![](http://upload-images.jianshu.io/upload_images/291600-6f8e9ff65bf631f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

For example, here are 5 gradients, 4 weights and 1 bias. 

![](http://upload-images.jianshu.io/upload_images/291600-23bc396e09d8139f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

It starts with the left and works back through the layers, like so. Each time it calculates a gradient, it uses all the previous gradients up to that point.

![](http://upload-images.jianshu.io/upload_images/291600-44f697c99f9eabd0.gif?imageMogr2/auto-orient/strip)

So, let's start with that node. That edge uses the gradient at that node. And the next. So far things are simple.

![](http://upload-images.jianshu.io/upload_images/291600-a2d602cf560907fd.gif?imageMogr2/auto-orient/strip)

As you keep going back, things get a bit more complex - that one for example uses a lot of gradients, even though this is a relatively simple net. If your net gets larger and deeper, like this one, it gets even worse.

![](http://upload-images.jianshu.io/upload_images/291600-de5c3d9af77a018b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

But why is that? Well, a gradient at any point is the product of the previous gradients up to that point. And the product of two numbers between 0 and 1 gives you a smaller number.

![](http://upload-images.jianshu.io/upload_images/291600-a7a4f7af3c2a6410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

 Say this rectangle is a one. 

![](http://upload-images.jianshu.io/upload_images/291600-265816c3fc9d282e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

Also, say there are two gradients - a fourth - like that

![](http://upload-images.jianshu.io/upload_images/291600-e99e26fe47452fe4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

 - and a third.

![](http://upload-images.jianshu.io/upload_images/291600-b09b63e8b060056c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

If you multiply them, you get a fourth of a third which is a twelfth.

![](http://upload-images.jianshu.io/upload_images/291600-e27dc07fcdbeaa49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

A fourth of a twelfth is a forty-eighth.

![](http://upload-images.jianshu.io/upload_images/291600-15d7e3479beea24a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

You can see that numbers keep getting smaller the more you multiply. Have you ever had this issue while training a neural network with **backpropagation**? If so, please comment and let me know your thoughts.

As a result of all this, **backprop** ends up taking a lot of time to train the net, and the accuracy is often very low.

![](http://upload-images.jianshu.io/upload_images/291600-64c3c64229a301a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

Up until 2006, deep nets were still underperforming shallow nets and other machine learning algorithms. But everything changed after three breakthrough papers published by Hinton, Lecun, and Bengio in 2006 and 2007.

![](http://upload-images.jianshu.io/upload_images/291600-4391e6c11ad44c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

In the next video, we'll begin taking a closer look at these breakthroughs, starting with the **Restricted Boltzmann Machine**（受限波兹曼机）.

![](http://upload-images.jianshu.io/upload_images/291600-f7ab81d3c318996b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

# 相关链接
[视频链接](https://www.youtube.com/watch?v=SKMpmAOUa2Q&index=5&list=PLjJh1vlSEYgvGod9wWiydumYl8hOXixNu)
[本系列文章目录](http://www.jianshu.com/p/4f7e4f27dad9)

# 拓展阅读
* [关于梯度消失，梯度爆炸的问题](http://blog.csdn.net/qq_29133371/article/details/51867856)
* [反向传播（Backpropagation）算法的数学原理](https://my.oschina.net/findbill/blog/529001)
* [如何直观的解释back propagation算法？](https://www.zhihu.com/question/27239198)
* [Coursera机器学习-第四周-Neural Network ForwardPropagation](http://blog.csdn.net/dingchenxixi/article/details/51371641)