---
title: 当你刷新RecyclerView程序崩掉的时候
date: 2017-03-12 16:15:59
tags: 
	- Android
	- RecyclerView
	- 刷新
	- 崩溃
categories: Android从入门到炸机
---
# 崩溃再现
今天测试 APP的时候发现一个有关RecyclerView的BUG，我们先上图来看看崩溃情况：

![崩溃再现](http://upload-images.jianshu.io/upload_images/291600-c3ac44b293b1d8c1.gif?imageMogr2/auto-orient/strip)

# 报错信息
摸着后脑勺，一脸蒙圈地看着Android Studio打印着下面这段日志：

```
java.lang.IllegalArgumentException: Scrapped or attached views may not be recycled. isScrap:false isAttached:true
at android.support.v7.widget.RecyclerView$Recycler.recycleViewHolderInternal(RecyclerView.java:5659)
	at android.support.v7.widget.RecyclerView$Recycler.recycleView(RecyclerView.java:5603)
	at android.support.v7.widget.GapWorker.prefetchPositionWithDeadline(GapWorker.java:277)
	at android.support.v7.widget.GapWorker.flushTaskWithDeadline(GapWorker.java:324)
	at android.support.v7.widget.GapWorker.flushTasksWithDeadline(GapWorker.java:337)
	at android.support.v7.widget.GapWorker.prefetch(GapWorker.java:344)
	at android.support.v7.widget.GapWorker.run(GapWorker.java:370)
	at android.os.Handler.handleCallback(Handler.java:743)
	at android.os.Handler.dispatchMessage(Handler.java:95)
	at android.os.Looper.loop(Looper.java:150)
	at android.app.ActivityThread.main(ActivityThread.java:5665)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:822)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:712)
```

# 寻找解决方法
定眼一看，这个信息并不是传统型经典款的异常，不像空指针异常，找不到出错的地方。无奈之下，寻求万能的谷歌。通过查询，得到如下两种原因及解决方案：

* android:animateLayoutChanges与RecyclerView刷新共用

  ![图片截自StackOverFlow](http://upload-images.jianshu.io/upload_images/291600-ae63d153be9a5c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  通过蹩脚的翻译，得到如下信息：
> 这个错误的原因是xml布局文件中将*android:animateLayoutChanges *设置为*true* 并且*java* 代码里对*RecyclerView* 的*adapter* 调用了*notifyDataSetChanged()* 方法。

  由此可知晓android:animateLayoutChanges="true"与RecyclerView的刷新不可同时存在，那么**为什么同时存在会报错呢？**
我们知道android:animateLayoutChanges="true"是在列表增删Item的时候调用系统自带的动画效果，而RecyclerView的机制是对子视图的复用，不会在真正意义上对Item的控件进行增加、删除，与android:animateLayoutChanges原理相悖，因此会报错。

* item中获取焦点的控件使之无法销毁

  ![图片截自StackOverFlow](http://upload-images.jianshu.io/upload_images/291600-70b7cd998daaa1e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  从回答中，我们可以看到，在多个Item包含EditText的时候，因为其中一个EditText抢占了RecyclerView的焦点，导致无法被回收，所以报错。其**解决方法**为给RecyclerView添加focusableInTouchMode属性，使之在触摸模式下（手指接触屏幕）依然可以获取到焦点，从而对Item进行回收刷新。

# 找到真正原因

尝试了上述两种方法，发现问题依然没有解决，因问题出现在刷新的地方，而我使用的是XRecyclerView框架，所以到onRefresh方法里去找原因，发现了问题的真正原因：

![onRefresh操作代码](http://upload-images.jianshu.io/upload_images/291600-c6d9c86f93311f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上述代码中可以看到，我先清空了已有的数据，然后再获取网络接口的数据，而从清空数据到获取到数据的这段时间里，List中的数据是不存在的，所以给了RecyclerView要回收Item，但是View没有被回收的假象（此时并没有执行notifyDataSetChanged()方法），因此程序报错。

其解决方法是：将列表清空的方法放到获取到接口数据以后执行。

以上就是本文的所有内容，对于上述解决方法的理解存在“主观臆断”的倾向，因此本文仅供参考，若有错误的地方，欢迎大家在文章下方评论指正！

# 参考：
http://blog.csdn.net/io_field/article/details/53083586
http://stackoverflow.com/questions/26477660/recyclerview-crashes-when-scrapped-or-attached-views-may-not-be-recycled#